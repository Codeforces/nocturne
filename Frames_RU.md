# Фреймы #

Часто некоторые сложные страницы хочется декомпозировать, так как разные страницы содержат одинаковые элементы (например, панельку с новостями). Nocturne предусматривает выделение таких компонент во фреймы. Каждый фрейм имеет свой контроллер (класс, унаследованный от org.nocturne.main.Frame) и может иметь свой шаблон. Жизненный цикл фрейма повторяет цикл страницы и он начинается, когда для заданного фрейма someFrame вызывается код parse("parsedFrame", someFrame) (или parse(someFrame)). Коротко:
  1. фрейм если надо инициализируется (ровно 1 раз на instance);
  1. initializeAction()
  1. Бросается событие, что срабатывают подписчики Events.beforeAction(SomeFrame.class, ...).
  1. Запускается validation-метод если надо. Используется action текущей страницы.
  1. Запускается action-метод (если прошла валидация)
  1. Запускается invalid-метод (если не прошла валидация)
  1. Бросается событие, что срабатывают подписчики Events.afterAction(SomeFrame.class, ...).
  1. finalizeAction()

Тот компонент, что вызвал parse("parsedFrame", someFrame) теперь имеет результат того, что отрендерил фрейм во внутреннем мэпе по ключу "parsedFrame". Теперь, если в шаблоне этого компонента написано <@frame name="parsedFrame"/>, то на это место вставится результат рендеринга фрейма. Таким образом, включать в себя фреймы могут страницы и другие фреймы.

В компонентах, которые содержат фреймы их лучше всего инстанциировать с помощью IoC через аннотацию @Inject.

# Пример работы с фреймом #
```
@Link(";home")
public class IndexPage extends Page {
    @Inject
    private LoginFormFrame loginForm;

    public void action() {
        parse("loginForm", loginForm);
    }
}
```
И шаблон IndexPage.ftl:
```
<#import "macros/common.ftl" as common>

<@common.page>
    <@frame name="loginFrame"/>
    <div>
        ...
    </div>
</@common.page>
```