Ноктюрн обращает внимание только на те запросы, которые соответствуют url-pattern для
фильтра org.nocturne.main.DispatchFilter.

В том случае, если URL запроса удовлетворяет параметру nocturne.skip-regex, то ноктюрн перестает обрабатывать этот запрос и отдает его filterChain.

В противном случае запускается механизм поиска подходящей страницы (Page) для обработки запроса. Для этого URL и request.getParameterMap() передаются в класс, заданный в nocturne.request-router, а тот возвращает специальный объект Resolution, у которого есть три поля: pageClassName, action, и overrideParameters. Первый обозначает имя класса страницы (контроллера), второй action внутри данной страницы, а третий --- это Map, которым переписываются (или добавляются) параметры в запрос.

После того как Page обнаружен, то экземпляр страницы создается или берется из пула страниц и далее уже идет работа с ним. Заметим, что из пула страницы раздаются таким образом, что один экземпляр страницы не обрабатывается единовременно 2-мя и более потоками. Таким образом, заботится о потоковой безопасности страниц не надо.

Далее:
  1. вызываются методы beforeProcessPage() у зарегистрированных PageRequestListener-ов.
  1. Если страница была только что создана, то у нее вызывается метод init(). Таким образом, у каждой страницы этот метод вызывается ровно 1 раз (при первом обращении после создания).
  1. Зовется метод initializeAction() (не зависимо какой action ожидается). На этот момент страница уже готова к использованию, в нее внедрены параметры.
  1. Генерируется событие Events.beforeAction() - и все кто подписан на этот класс этой страницы или ее предка будут нотифицированы
  1. Вызывается нужный валидационный метод для action. Это либо метод с именем validate(), либо метод с аннотацией @Validate("имя action'а"). Если аннотация задана без параметра, то аннотированный метод становится дефолтным. Если нужный action не найден, никакой метод не вызывается. Подробности о валидации смотрите на [ValidationFlow\_RU](ValidationFlow_RU.md). Если валидационный метод возвращает true, то управление передается на первый из двух следующих пунктов, иначе на второй:
    * Вызывается нужный action: это либо метод action() (по умолчанию), либо любой void метод с пустым списком параметров и аннотацией @Action("имя action'a"). Если аннотация задана без параметра, то аннотированный метод становится дефолтным. Если нужный action не найден, то зовется default. Страницы могут на этой стадии (ну впрочем и на других тоже могут) парсить фреймы. Об этом читайте на [Frames\_RU](Frames_RU.md).
    * Вызывается нужный invalid метод: это либо метод invalid() (по умолчанию), либо любой void метод с пустым списком параметров и аннотацией @Invalid("имя action'a"). Если аннотация задана без параметра, то аннотированный метод становится дефолтным. Если нужный invalid метод не найден, то зовется default. Если и его нет, то ничего не зовется.
  1. Генерируется событие Events.afterAction() - и все кто подписан на этот класс этой страницы или ее предка будут нотифицированы
  1. Вызывается метод finalizeAction()
  1. Если страница не отказалась от обработки шаблона (т.е. не вызвала skipTemplate()), то инициируется процесс обработки шаблона. По умолчанию имя шаблона совпадает с коротким именем класса страницы + суффикс ".ftl", но имя можно менять с помощью setTemplateName.
  1. Вызываются методы afterProcessPage() у зарегистрированных [PageRequestListener](PageRequestListener_RU.md)-ов.
  1. Если на странице был вызван метод setProcessChain(true), то пара request-response передается в filterChain.

При выпадении exception - управление передается на пункт 9, но пункт 10 игнорируется. Методы abortXXX() инициируют AbortException, предварительно записывая в response соответствующий redirection.