#summary Предложение по кэшированию

= Предложение по осуществлению кэширования =

== Кэширование вызовов методов (обычно для DAO) ==
Используются две аннотации: {{{@CacheCall}}} и {{{@InvalidateCacheCall}}}. Примеры:
{{{
public class UserDaoImpl extends ApplicationDaoImpl<User> implements UserDao {
    ...
    @CacheCall(cacheName = "User")
    public User find(long id) {
        ...
    }
    ...
    @InvalidateCacheCall("User")
    public void update(User user) {
        ...
    }
    ...
}
}}} 

У {{{CacheCall}}} предполагаются параметры:

# cacheName - имя кэша, значение будет кэшироваться в кэш (или браться из кэша) с этим именем
# ttl - time to live (время жизни кэша) в секундах, т.е. максимальное время жизни закэшированного результата исполнения метода

У {{{InvalidateCacheCall}}} предполагается параметр value, который может строкой или массивом, содержащим имена кэшей для инвалидации (тотального их очищения).

Функционирует так:

# Если класс загружается через IoC, то средствами Google Guice он обрабатывается с помощью 
interceptor-а, который и обрабатывает эти аннотации. 
# Когда зовется метод с {{{@CacheCall}}}, то вычисляется хеш-значение от массива его аргументов + имя метода и класса. Если есть в заданном кэше запись с таким ключом, то метод не вызывается, а берется значение из кэша в качестве результата. Иначе, вызов производится, а значение складывается в кэш по ключу, равному вычисленному хэш-коду. 
# Когда зовется метод с {{{@InvalidateCacheCall}}}, то записи во всех кэшах, которые в нем указаны как аргументы, чистятся.

Если приложение запущено в debug mode, то при обработке {{{@CacheCall}}} вызов метода производится в любом случае, но возвращаемый результат проверяется на равенство с тем, что лежит в кэше. Если не совпало, то об этом пишется в log и инициируется исключение {{{CacheLogicException}}}.

Кэширование action-методов компонентов (контроллеров):
{{{
public class UserPage extends Page {
    ...
    @Cacheable
    public void onShowStatus() {
        ...
    }
    ...
}
}}} 