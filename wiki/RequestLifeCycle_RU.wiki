#summary Описывает жизненный цикл одного HTTP-запроса.

Ноктюрн обращает внимание только на те запросы, которые соответствуют url-pattern для
фильтра org.nocturne.main.DispatchFilter.

В том случае, если URL запроса удовлетворяет параметру nocturne.skip-regex, то ноктюрн перестает обрабатывать этот запрос и отдает его filterChain.

В противном случае запускается механизм поиска подходящей страницы (Page) для обработки запроса. Для этого URL и request.getParameterMap() передаются в класс, заданный в nocturne.request-router, а тот возвращает специальный объект Resolution, у которого есть три поля: pageClassName, action, и overrideParameters. Первый обозначает имя класса страницы (контроллера), второй action внутри данной страницы, а третий --- это Map, которым переписываются (или добавляются) параметры в запрос.

После того как Page обнаружен, то экземпляр страницы создается или берется из пула страниц и далее уже идет работа с ним. Заметим, что из пула страницы раздаются таким образом, что один экземпляр страницы не обрабатывается единовременно 2-мя и более потоками. Таким образом, заботится о потоковой безопасности страниц не надо. 

Далее:
 # вызываются методы beforeProcessPage() у зарегистрированных PageRequestListener-ов.
 # Если страница была только что создана, то у нее вызывается метод init(). Таким образом, у каждой страницы этот метод вызывается ровно 1 раз (при первом обращении после создания).
 # Зовется метод initializeAction() (не зависимо какой action ожидается). На этот момент страница уже готова к использованию, в нее внедрены параметры.
 # Генерируется событие Events.beforeAction() - и все кто подписан на этот класс этой страницы или ее предка будут нотифицированы
 # Вызывается нужный валидационный метод для action. Это либо метод с именем validate(), либо метод с аннотацией @Validate("имя action'а"). Если аннотация задана без параметра, то аннотированный метод становится дефолтным. Если нужный action не найден, никакой метод не вызывается. Подробности о валидации смотрите на [ValidationFlow_RU]. Если валидационный метод возвращает true, то управление передается на первый из двух следующих пунктов, иначе на второй:
   * Вызывается нужный action: это либо метод action() (по умолчанию), либо любой void метод с пустым списком параметров и аннотацией @Action("имя action'a"). Если аннотация задана без параметра, то аннотированный метод становится дефолтным. Если нужный action не найден, то зовется default.
   * Вызывается нужный invalid метод: это либо метод invalid() (по умолчанию), либо любой void метод с пустым списком параметров и аннотацией @Invalid("имя action'a"). Если аннотация задана без параметра, то аннотированный метод становится дефолтным. Если нужный invalid метод не найден, то зовется default. Если и его нет, то ничего не зовется.
 # Генерируется событие Events.afterAction() - и все кто подписан на этот класс этой страницы или ее предка будут нотифицированы
 # Вызывается метод finalizeAction()
 # Если страница не отказалась от обработки шаблона (т.е. не вызвала skipTemplate()), то инициируется процесс обработки шаблона. По умолчанию имя шаблона совпадает с коротким именем класса страницы + суффикс ".ftl", но имя можно менять с помощью setTemplateName.
 # Вызываются методы afterProcessPage() у зарегистрированных [PageRequestListener_RU PageRequestListener]-ов.
 # Если на странице был вызван метод setProcessChain(true), то пара request-response передается в filterChain.

При выпадении exception - управление передается на пункт 10, но пункт 11 игнорируется. Методы abortXXX() инициируют AbortException, предварительно записывая в response соответствующий redirection.